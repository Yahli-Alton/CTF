// tmpbe8vgsg2_text.c
// Generated by decompiling tmpbe8vgsg2
// using Reko decompiler version 0.11.5.0.

#include "tmpbe8vgsg2.h"

// 00000000000008E0: void main()
void main()
{
	struct Eq_107 ** s1_107;
	word64 a6_6 = g_qw0C50;
	word64 a1_7 = g_qw0C58;
	word64 a2_8 = g_qw0C60;
	word64 a3_9 = g_qw0C68;
	word64 a4_10 = g_qw0C70;
	Eq_24 tLoc50;
	tLoc50.dw0028 = g_dw0C78;
	tLoc50.qw0000 = a6_6;
	tLoc50.qw0008 = a1_7;
	tLoc50.qw0010 = a2_8;
	tLoc50.qw0018 = a3_9;
	tLoc50.qw0020 = a4_10;
	fn0000000000000A4C(&tLoc50);
	struct Eq_64 ** a0_48 = _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(0x1912, g_qw2070, &tLoc50);
	struct Eq_71 * s1_61 = Mem25[Mem25[Mem25[a0_48 + 0x00:word64] + -24:word64] + a0_48 + 0x00F0:word64];
	if (s1_61 == null)
	{
		std::__throw_bad_cast();
		word64 s0_51;
		word64 ra_49;
		_ZNSt8ios_base4InitC1Ev(8344, s0_51, ra_49);
		void * s0_79;
		__cxa_atexit(g_ptr2088, s0_79, &g_v2000);
	}
	else
	{
		struct Eq_64 ** s0_129 = a0_48;
		if ((word64) s1_61->b0038 == 0x00)
		{
			_ZNKSt5ctypeIcE13_M_widen_initEv(s1_61);
			<anonymous> * a5_118 = (<anonymous> *) *((char *) *s1_107 + 48);
			a5_118();
		}
		std::ostream::put((char) s0_129);
		std::ostream::flush();
	}
}

Eq_128 g_t0920 = ??/* Unexpected function type (fn int32 (int32, (ptr64 (ptr64 char)), (ptr64 (ptr64 char)))) */ ; // 0000000000000920
// 0000000000000994: void fn0000000000000994(Register (ptr64 Eq_120) a0, Stack word32 dwArg00, Stack (ptr64 char) ptrArg08)
void fn0000000000000994(void (* a0)(), word32 dwArg00, char * ptrArg08)
{
	fn00000000000009B6();
	word64 qwArg00;
	Eq_142 fp;
	__libc_start_main(g_ptr2060, (int32) qwArg00, &ptrArg08, null, null, a0, fp & -16);
	__ebreak();
	fn00000000000009B6();
}

// 00000000000009B6: void fn00000000000009B6()
// Called from:
//      fn0000000000000994
void fn00000000000009B6()
{
}

// 0000000000000A4C: void fn0000000000000A4C(Register (ptr64 Eq_51) a0)
// Called from:
//      main
void fn0000000000000A4C(struct Eq_51 * a0)
{
	if ((word64) a0->b002A != 0x00)
		return;
	ui64 a5_6 = 0x00 - a0;
	ui64 a4_12;
	int64 a1_10;
	struct Eq_51 * a3_16;
	if ((a5_6 & 7) != 0x00)
	{
		a4_12 = (word64) a0->b002B;
		a0->b0000 = a0->b0000 ^ (byte) a4_12;
		if ((a5_6 & 6) != 0x00)
		{
			a0->b0001 = a0->b0001 ^ (byte) a4_12;
			a1_10 = 40;
			a3_16 = (struct Eq_51 *) &a0->b0002;
			if ((a5_6 & 7) > 0x02)
			{
				a0->b0002 = a0->b0002 ^ (byte) a4_12;
				a1_10 = 39;
				a3_16 = (struct Eq_51 *) &a0->b0003;
				if ((a5_6 & 0x04) != 0x00)
				{
					a0->b0003 = a0->b0003 ^ (byte) a4_12;
					if ((a5_6 & 7) > 0x04)
					{
						a0->b0004 = a0->b0004 ^ (byte) a4_12;
						if ((a5_6 & 7) != 0x05)
						{
							a0->b0005 = a0->b0005 ^ (byte) a4_12;
							a1_10 = 36;
							a3_16 = (struct Eq_51 *) &a0->b0006;
							if ((a0 + -1 & 0x07) == 0x00)
							{
								a0->b0006 = a0->b0006 ^ (byte) a4_12;
								a3_16 = a0 + 7;
								a1_10 = 35;
							}
						}
						else
						{
							a3_16 = (struct Eq_51 *) &a0->b0005;
							a1_10 = 37;
						}
					}
					else
					{
						a3_16 = (struct Eq_51 *) &a0->b0004;
						a1_10 = 38;
					}
				}
			}
		}
		else
		{
			a3_16 = (struct Eq_51 *) &a0->b0001;
			a1_10 = 41;
		}
	}
	else
	{
		a4_12 = (word64) a0->b002B;
		a3_16 = a0;
		a1_10 = 42;
	}
	struct Eq_206 * a2_64 = (struct Eq_206 *) (a0 + (a5_6 & 7) /64 44);
	ui64 a5_76 = a4_12 << 0x08 | a4_12 | a4_12 << 0x10 | a4_12 << 0x18 | a4_12 << 0x20 | a4_12 << 0x28 | a4_12 << 0x30 | a4_12 << 56;
	ui64 t4_79 = a5_76 ^ a2_64->qw0000;
	ui64 t3_81 = a5_76 ^ a2_64->qw0008;
	ui64 t1_82 = a5_76 ^ a2_64->qw0010;
	a2_64->qw0018 = a5_76 ^ a2_64->qw0018;
	a2_64->qw0000 = t4_79;
	a2_64->qw0008 = t3_81;
	a2_64->qw0010 = t1_82;
	Eq_263 a6_78 = 42 - (a5_6 & 7);
	struct Eq_51 * a4_90;
	int64 a5_107;
	if (a6_78 >> 0x03 == 0x05)
	{
		a2_64->qw0020 = a5_76 ^ a2_64->qw0020;
		a4_90 = a3_16 + 40;
		a5_107 = a1_10 + -40;
		if (a6_78 == 40)
			goto l0000000000000C04;
	}
	else
	{
		a4_90 = a3_16 + 32;
		a5_107 = a1_10 + -32;
	}
	a4_90->b0000 = a4_90->b0000 ^ a0->b002B;
	if (a5_107 != 0x01)
	{
		a4_90->b0001 = a4_90->b0001 ^ a0->b002B;
		if (a5_107 != 0x02)
		{
			a4_90->b0002 = a4_90->b0002 ^ a0->b002B;
			if (a5_107 != 0x03)
			{
				a4_90->b0003 = a4_90->b0003 ^ a0->b002B;
				if (a5_107 != 0x04)
				{
					a4_90->b0004 = a4_90->b0004 ^ a0->b002B;
					if (a5_107 != 0x05)
					{
						a4_90->b0005 = a4_90->b0005 ^ a0->b002B;
						if (a5_107 != 0x06)
							a4_90->b0006 = a4_90->b0006 ^ a0->b002B;
					}
				}
			}
		}
	}
l0000000000000C04:
	a0->b002A = 0x01;
}

// tmpbe8vgsg2_got.c
// Generated by decompiling tmpbe8vgsg2
// using Reko decompiler version 0.11.5.0.

// #include "tmpbe8vgsg2.h"

<anonymous> * g_ptr2008 = &g_tFFFFFFFF; // 0000000000002008
int32 (* g_ptr2060)(int32 a0, char ** a1, char ** a2) = &g_t0920; // 0000000000002060
word64 g_qw2070 = 0x00; // 0000000000002070
void (* g_ptr2088)(void * a0) = null; // 0000000000002088
// tmpbe8vgsg2_rodata.c
// Generated by decompiling tmpbe8vgsg2
// using Reko decompiler version 0.11.5.0.

// #include "tmpbe8vgsg2.h"

word64 g_qw0C50 = 8311425348078369131; // 0000000000000C50
word64 g_qw0C58 = 0x75447F5875655E75; // 0000000000000C58
word64 g_qw0C60 = 0x6378756445751967; // 0000000000000C60
word64 g_qw0C68 = 0x47751E1C7C076979; // 0000000000000C68
word64 g_qw0C70 = 0xB0B6F440B62491E; // 0000000000000C70
word32 g_dw0C78 = 0x2A002A57; // 0000000000000C78
// tmpbe8vgsg2_data.c
// Generated by decompiling tmpbe8vgsg2
// using Reko decompiler version 0.11.5.0.

// #include "tmpbe8vgsg2.h"

void g_v2000 = ??void??; // 0000000000002000
// tmpbe8vgsg2_plt.c
// Generated by decompiling tmpbe8vgsg2
// using Reko decompiler version 0.11.5.0.

// #include "tmpbe8vgsg2.h"

// 0000000000000840: void __cxa_atexit(Register word64 t1, Register word64 t3)
void __cxa_atexit(word64 t1, word64 t3)
{
	<anonymous> * t3_8 = g_ptr2008;
	t3_8();
}

